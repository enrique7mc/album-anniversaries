{"ast":null,"code":"import { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { mergeMap } from 'rxjs/operators';\nimport { map, filter, bufferCount } from 'rxjs/operators';\nimport { artistsLocalUrl } from './constants';\nimport { BehaviorSubject, Subject, from } from 'rxjs';\nimport { APP_CONFIG } from './app-config';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let SpotifyService = /*#__PURE__*/(() => {\n  class SpotifyService {\n    constructor(http, config) {\n      this.http = http;\n      this.isDev = config.isDev;\n      this.dataStore = {\n        artists: []\n      };\n      this._artists = new BehaviorSubject([]);\n    }\n    get artists() {\n      return this._artists.asObservable();\n    }\n    get artistsUrl() {\n      return this.isDev ? artistsLocalUrl : 'https://api.spotify.com/v1/me/top/artists?limit=50';\n    }\n    artistUrl(id) {\n      return `https://api.spotify.com/v1/artists/${id}/albums?include_groups=album&limit=50`;\n    }\n    // TODO: figure out the optimal way to signal this method is done loading.\n    loadArtistsWithAlbums(accessToken) {\n      const httpOptions = {\n        headers: new HttpHeaders({\n          Authorization: `Bearer ${accessToken}`\n        })\n      };\n      const done$ = new Subject();\n      // TODO: try to compose the artist and albums observables instead of\n      // handling a nested subscription.\n      this.http.get(this.artistsUrl, httpOptions).subscribe(data => {\n        let artistsResponse = data.items;\n        if (this.isDev) {\n          artistsResponse = data.items.slice(0, 10);\n        }\n        const artists = artistsResponse.map(item => {\n          return {\n            id: item.id,\n            href: item.href,\n            name: item.name,\n            images: item.images,\n            popularity: item.popularity,\n            external_url: item.external_urls.spotify,\n            albums: []\n          };\n        });\n        const artistAlbumRequests = from(artists).pipe(mergeMap(artist => this.http.get(this.artistUrl(artist.id), httpOptions).pipe(map(data => {\n          // TODO: extract this into its own function\n          const albums = data.items.map(item => Object.assign({}, item, {\n            artist_id: artist.id\n          })).filter(item => item.release_date_precision === 'day').filter(item => SpotifyService.albumHadBirthdayPastWeek(item) || SpotifyService.albumReleasedPastYear(item)).map(item => ({\n            id: item.id,\n            artist_id: item.artist_id,\n            name: item.name,\n            release_date: item.release_date,\n            release_date_precision: item.release_date_precision,\n            images: item.images,\n            external_url: item.external_urls.spotify\n          }));\n          return albums;\n        }))), filter(albums => albums.length > 0), map(albums => {\n          const matchingArtist = artists.find(a => a.id === albums[0].artist_id);\n          matchingArtist.albums.push(...albums);\n          return matchingArtist;\n        }));\n        artistAlbumRequests.pipe(bufferCount(5)).subscribe(artistList => {\n          this.dataStore.artists = [...this.dataStore.artists, ...artistList];\n          this._artists.next(Object.assign({}, this.dataStore).artists);\n        }, err => {\n          // do nothing\n        }, () => {\n          // <----\n          done$.next(true);\n        });\n      });\n      return done$.asObservable();\n    }\n    // TODO: refactor this to make more generic\n    static albumHadBirthdayPastWeek(album) {\n      const today = new Date(Date.now());\n      const albumDate = new Date(Date.parse(`${album.release_date} 00:00:00 -0800`));\n      albumDate.setFullYear(today.getFullYear());\n      const millisecondsInAWeek = 604800000;\n      const dateDiffMillis = today.getTime() - albumDate.getTime();\n      return dateDiffMillis > 0 && dateDiffMillis < millisecondsInAWeek;\n    }\n    static albumReleasedPastYear(album) {\n      const albumDate = new Date(Date.parse(`${album.release_date} 00:00:00 -0800`));\n      const now = Date.now();\n      const millisecondsInAYear = 31536000000;\n      return Math.abs(now - albumDate.getTime()) < millisecondsInAYear;\n    }\n    // TODO: replace with array.flat()\n    flatten(input) {\n      const stack = [...input];\n      const res = [];\n      while (stack.length) {\n        // pop value from stack\n        const next = stack.pop();\n        if (Array.isArray(next)) {\n          // push back array items, won't modify the original input\n          stack.push(...next);\n        } else {\n          res.push(next);\n        }\n      }\n      //reverse to restore input order\n      return res.reverse();\n    }\n    static {\n      this.ɵfac = function SpotifyService_Factory(t) {\n        return new (t || SpotifyService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(APP_CONFIG));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: SpotifyService,\n        factory: SpotifyService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return SpotifyService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}